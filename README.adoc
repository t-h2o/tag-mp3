= MP3 tag with name file

ifdef::env-github[]
++++
<p align="center">
  <a href="https://youtu.be/oqVy6eRXc7Q"><img src="bob.png"></a>
</p>
++++
endif::[]

ifndef::env-github[]
image::bob.png[align=center, link="https://youtu.be/oqVy6eRXc7Q"]
endif::[]


I recently downloaded with torrent the Bob Marley\'s discography and there is all metadata in the name file but not the MP3 file. My goal is to parse name file for tagging the MP3 files.

== Reasoning for ruilding my script

=== 1. Find a language

For this type of use (files manipulation), bash script is a good way.

=== 2. Collect data

=== 2.1 scanf

I know `scanf` from C language. You give a patter to `scanf` and he collectes data. I search something like scanf for bash script.

I found on https://www.reddit.com/r/bash/comments/gxygww/why_isnt_there_scanf_or_equivalent_in_bash/[reddit] an example.

[source, bash]
----
#!/bin/bash

pattern="Fan: (.+) rpm CPU die temperature: (.+) C"
if [[ "Fan: fann rpm CPU die temperature: 42 C" =~ $pattern ]]; then
    fan=${BASH_REMATCH[1]}
    cpu=${BASH_REMATCH[2]}
fi
echo "$fan" "$cpu"
----

[quote]
I use https://www.shellcheck.net/[shellcheck] for get good practices for creating shell scripts.

=== 2.2 A loop for each files

I need a loop for each files. I found an exmample on https://w3guides.com/tutorial/bash-for-each-file-in-folder#bash-for-each-file-in-folder[w3guides.com]

[source, bash]
----
#!/bin/bash

for filename in ./*; do
    echo "${filename}"
done
----

=== 2.3 Parse the filename

For each tracks in an album, we have to collect:

* Title
* Track number

We already have:

* Artist
* Album
* Year

Example of filename for `Keep On Skanking`:
[source]
----
01 - All In One.mp3
02 - Keep On Moving.mp3
03 - Keep On Skanking.mp3
04 - Shocks Of Mighty (Soul Almighty Ve.mp3
05 - Brand New Second Hand.mp3
06 - Jungle Dub.mp3
07 - Satisfy My Soul Babe (Version).mp3
08 - Dracula (Version).mp3
09 - Vs. Lee Scratch Perry Dreamland (Featuring Bunny Wailer).mp3
10 - Comma Comma.mp3
----

=== 2.4 awk

After research I refind this dark tool. I had choosen to never learn to use this, because it's a very hard tool.

[source,man]
----
NAME
       awk — pattern scanning and processing language
----

==== 2.4.1 Print the track number

For each `.mp3` files:

[source, bash]
----
#!/bin/bash

for filename in ./\.*mp3; do
    echo "${filename}"
    echo "${filename}" | awk '{printf "Track number: %d\n", substr($1, 3)}'
done

# OUTPUT:
# ./01 - All In One.mp3
# Track number: 1
----

If I take this filename as example `./01 - All In One.mp3`. The first element is `./01`. I have to do a substring, so begin my substring to the third character.

[quote]
I find it weird, this time the index start with 1 and not 0.

With the substring I get `01` instead of `./01`. And then I use `%d` of `printf` for convert to a number.

==== 2.4.3 Print the track title

[source,bash]
----
#!/bin/bash

for filename in ./*\.mp3; do

    echo "${filename}"
    echo "${filename}" | awk '{printf "Titel: " }{i = 3} {while (i + 1 <= NF ) {printf "%s ", $i; i++}} {printf "%s\n", substr($i, 0, length($i) - 4)}'
done

# OUTPUT:
# ./01 - All In One.mp3
# Titel: All In One
----

1. Just print `"Titel: "`.
2. Set `i = 3`.
3. `While (i + 1 <= NF)` print each elements.

[quote]
NF: The number of fields in the current record.

[start=4]
4. Remove `./mp3`: Substing of the last element, start a the beginning of the string, stop at the end minus four.

== 3. Tag the track

It's the very easy step, after saving `track` and `title`. Just use mp3info for tagging them.

[source,bash]
----
#!/bin/bash

for filename in ./*\.mp3; do

    track=$(echo "${filename}" | awk '{printf "%d", substr($1, 3)}')
    title=$(echo "${filename}" | awk '{i = 3} {while (i + 1 <= NF ) {printf "%s ", $i; i++}} {printf "%s", substr($i, 0, length($i) - 4)}')
    printf "Track: %s\tTitle: %s\n" "${track}" "${title}"
    mp3info -t "${title}" -n "${track}" "${filename}"
done
----

== Bonus: Collect folder data

We have to collect from the foder

* Artist
* Year of the album
* Album name

The tracks are tidied up like this:
----
Bob Marley - 1967 - Keep On Skanking
├── 01 - All In One.mp3
├── 02 - Keep On Moving.mp3
└── [...]
Bob Marley - 1970 - African Herbsman
├── 01 - Riding High.mp3
├── 02 - Lively Up Yourself.mp3
└── [...]
----

For remove the `./` or `./${foldername}`, we can use `basename`.

== Final script

[source,bash]
----
#!/bin/bash

for folder in ./Bob*; do

    folder=$(basename "${folder}")
    artist="Bob Marley"
    year=$(echo "${folder}" | awk '{printf "%d", $4}')
    album=$(echo "${folder}" | awk '{i = 6} {while (i <= NF ) {printf "%s ", $i; i++}}')

    for filepath in "${folder}"/*\.mp3; do

        filename=$(basename "${filepath}")

        track=$(echo "${filename}" | awk '{printf "%d", $1}')
        title=$(echo "${filename}" | awk '{i = 3} {while (i + 1 <= NF ) {printf "%s ", $i; i++}} {printf "%s", substr($i, 0, length($i) - 4)}')

        mp3info -a "${artist}" -l "${album}" -y "${year}" -t "${title}" -n "${track}" "${filepath}"
        echo mp3info -a "${artist}" -l "${album}" -y "${year}" -t "${title}" -n "${track}" "${filepath}"
    done
done
----

== Conclusion

I said that `awk` is a dark and hard tool. But after spending a few hours on read manuals and manipulating this; I became familiar with him. With this project I learned basic of `awk` and new knowledges on `AsciiDoc` and `bash`.

=== The real conclusion

All the Bob Marley's tracks are tagged and tidied !

image::cmus.png["cmus view"]

== Other

=== Pattern matching

1. Use the bash shell
2. Enable the `extglob`
[source,bash]
----
shopt -s extglob
----

[start=3]
3. Try to list all but not MP3 files with
[source,bash]
----
ls !(*.mp3)
----
